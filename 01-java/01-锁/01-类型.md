# 锁
对关键资源的保护

## 重量级锁
- 1. 前提：存在大量线程请求资源；
- 2. 机制：使用“重量级”锁进行控制，通过互斥量(Mutex)来实现，一个线程进入来synchronized同步块，由于是“大量线程”，所以为了避免系统资源消耗过大，让其他线程进入阻塞状态；
- 3. 性能：java的线程是映射到操作系统上的线程，如果要阻塞或唤醒一个线程，需要依靠操作系统把线程从当前用户状态转化到核心态，需要消耗CPU很多时间，可能比业务处理的消耗时间还要长，导致实际业务处理所占比偏小，性能损失较大。


## 轻量级锁
 - 1. 前提：少量线程，不让其他线程进入阻塞状态；
 - 2. 机制：通过CAS(Compare)机制实现，如果其他的线程占用了锁，当前线程会通过自旋来获取锁，从而避免了线程状态的转变；
 - 3. 性能：消除系统互斥量带来的性能消耗，增加CAS带来的性能消耗。

## 偏向锁
- 1. 前提：锁不仅不存在多线程的竞争，而且总是由一个线程多次获得；
- 2. 机制：通过记录第一次进入同步块的线程id来实现，如果下一个要进入同步块的线程和记录的线程id相同，则说明这个锁由此线程占用，可以直接进入到同步块，不用执行CAS；
- 3. 性能：消除CAS带来的性能消耗，性能无限接近非同步。

## 对象头
### java对象的5中状态，Mard Word的区域
| 存储内容                             | 标志位 | 状态         |
|:------------------------------------ |:------ | ------------ |
| 对象哈希吗、对象分代年龄             | 01     | 未锁定       |
| 指向锁记录的指针                     | 00     | 轻量级锁     |
| 指向重量级锁的指针                   | 10     | 指向重量级锁 |
| 空，不需要记录信息                   | 11     | GC标志       |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向       |

### 锁升级
  通过synchronized实现的同步锁，真实名称叫做重量级锁。但是重量级锁会造成线程排队（串行执行），且会使CPU在用户态和核心态之间频繁切换，所以代价高、效率低。为了提高效率，不会一开始就使用重量级锁，JVM在内部会根据需要，按如下步骤进行锁的升级：
 - 1.初期锁对象刚创建时，还没有任何线程来竞争，对象的Mark Word是下图的第一种情形，这偏向锁标识位是0，锁状态01，说明该对象处于无锁状态（无线程竞争它）。
 - 2.当有一个线程来竞争锁时，先用偏向锁，表示锁对象偏爱这个线程，这个线程要执行这个锁关联的任何代码，不需要再做任何检查和切换，这种竞争不激烈的情况下，效率非常高。这时Mark Word会记录自己偏爱的线程的ID，把该线程当做自己的熟人。如下图第二种情形。
 - 3.当有两个线程开始竞争这个锁对象，情况发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象并执行代码，锁对象的Mark Word就执行哪个线程的栈帧中的锁记录。如下图第三种情形。
 - 4.如果竞争的这个锁对象的线程更多，导致了更多的切换和等待，JVM会把该锁对象的锁升级为重量级锁，这个就叫做同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，这个监视器对象用集合的形式，来登记和管理排队的线程。

![99-images](测试结果)